#ifndef LOGGING_H_
#define LOGGING_H_

#include <QMutexLocker>
#include <QMutex>
#include <QQueue>
#include <QTime>

#include <stdint.h>
#include <time.h>
#include <unistd.h>

#include "mythbaseexp.h"  //  MBASE_PUBLIC , etc.
#include "verbosedefs.h"
#include "mthread.h"
#include "nzmqt.hpp"

#define LOGLINE_MAX (2048-120)

class QString;
class MSqlQuery;
class LoggingItem;

void loggingRegisterThread(const QString &name);
void loggingDeregisterThread(void);

class QWaitCondition;

typedef enum {
    kMessage       = 0x01,
    kRegistering   = 0x02,
    kDeregistering = 0x04,
    kFlush         = 0x08,
    kStandardIO    = 0x10,
    kInitializing  = 0x20,
} LoggingType;

class LoggerThread;

/// \brief The logging items that are generated by LOG() and are sent to the
///        console and to mythlogserver via ZeroMQ
class LoggingItem: public QObject
{
    Q_OBJECT;

    friend class LoggerThread;
    friend void LogPrintLine(uint64_t, LogLevel_t, const char *, int,
                   const char *, int, const char *, ... );
    friend void loggingRegisterThread(const QString &);

  public:
    char *getThreadName(void);
    int64_t getThreadTid(void);
    void setThreadTid(void);
    static LoggingItem *create(const char *, const char *, int, LogLevel_t,
                               LoggingType);
    static LoggingItem *create(QByteArray &buf);
    void deleteItem(void);
    QByteArray toByteArray(void);

  protected:
    QAtomicInt          refcount;
    uint64_t            threadId;
    uint32_t            usec;
    int                 line;
    int                 type;
    LogLevel_t          level;
    struct tm           tm;
    const char         *file;
    const char         *function;
    char               *threadName;
    char                message[LOGLINE_MAX+1];

  private:
    LoggingItem(const char *_file, const char *_function,
                int _line, LogLevel_t _level, int _type);
};

/// \brief The logging thread that consumes the logging queue and dispatches
///        each LoggingItem to mythlogserver via ZeroMQ
class LoggerThread : public QObject, public MThread
{
    Q_OBJECT
  public:
    LoggerThread(QString filename, bool progress, bool quiet);
    ~LoggerThread();
    void run(void);
    void stop(void);
    bool flush(int timeoutMS = 200000);
    void handleItem(LoggingItem *item);
  private:
    bool logConsole(LoggingItem *item);
    QWaitCondition *m_waitNotEmpty; ///< Condition variable for waiting
                                    ///  for the queue to not be empty
                                    ///  Protected by logQueueMutex
    QWaitCondition *m_waitEmpty;    ///< Condition variable for waiting
                                    ///  for the queue to be empty
                                    ///  Protected by logQueueMutex
    bool m_aborted;                 ///< Flag to abort the thread.
                                    ///  Protected by logQueueMutex
    bool m_initialWaiting;          ///< Waiting for the initial response from
                                    ///  mythlogserver
    QString m_filename; ///< Filename of debug logfile
    bool m_progress;    ///< show only LOG_ERR and more important (console only)
    int  m_quiet;       ///< silence the console (console only)
    nzmqt::PollingZMQContext *m_zmqContext; ///< ZeroMQ context to use in this logger
    nzmqt::ZMQSocket  *m_zmqSocket;  ///< ZeroMQ socket to talk to mythlogserver

  protected slots:
    void messageReceived(const QList<QByteArray>&);
};

#endif

/*
 * vim:ts=4:sw=4:ai:et:si:sts=4
 */
